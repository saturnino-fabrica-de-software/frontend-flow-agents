#!/usr/bin/env node

const { program } = require('commander');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs-extra');

// Import core modules
const { initProject } = require('../lib/init');
const { analyzeProject } = require('../lib/analyzer');
const { runPipeline } = require('../lib/orchestrator');
const { showStatus } = require('../lib/status');
const MarketplaceManager = require('../lib/marketplace-manager');
const FrameworkDetector = require('../lib/framework-detector');
const HealthMonitor = require('../lib/health-monitor');
const AnalyticsServer = require('../lib/analytics-server');

const packageJson = require('../package.json');

program
  .name('frontend-flow')
  .description('üöÄ Orquestrador de agentes IA para desenvolvimento React/TypeScript')
  .version(packageJson.version);

// Command: init - Setup project
program
  .command('init')
  .description('üîß Inicializar Frontend Flow no projeto atual')
  .option('--force', 'Sobrescrever configura√ß√£o existente')
  .action(async (options) => {
    console.log(chalk.blue('üöÄ Inicializando Frontend Flow...'));
    try {
      await initProject(process.cwd(), options);
      console.log(chalk.green('‚úÖ Frontend Flow configurado com sucesso!'));
      console.log(chalk.cyan('üìñ Use: frontend-flow "sua demanda" para come√ßar'));
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na inicializa√ß√£o:'), error.message);
      process.exit(1);
    }
  });

// Command: status - Show pipeline status
program
  .command('status')
  .description('üìä Mostrar status do pipeline atual')
  .action(async () => {
    try {
      await showStatus(process.cwd());
    } catch (error) {
      console.error(chalk.red('‚ùå Erro ao mostrar status:'), error.message);
      process.exit(1);
    }
  });

// Command: doctor - Check system health
program
  .command('doctor')
  .description('üè• Verificar sa√∫de do sistema e depend√™ncias')
  .action(async () => {
    try {
      const { checkSystemHealth } = require('../lib/doctor');
      await checkSystemHealth();
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na verifica√ß√£o:'), error.message);
      process.exit(1);
    }
  });

// Command: clean - Clean temporary files
program
  .command('clean')
  .description('üßπ Limpar arquivos tempor√°rios')
  .option('--all', 'Limpar todos os arquivos incluindo cache')
  .action(async (options) => {
    console.log(chalk.blue('üßπ Limpando arquivos tempor√°rios...'));
    try {
      const { cleanTemp } = require('../lib/cleanup');
      await cleanTemp(process.cwd(), options);
      console.log(chalk.green('‚úÖ Limpeza conclu√≠da!'));
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na limpeza:'), error.message);
      process.exit(1);
    }
  });

// Command: marketplace - Agent marketplace management
const marketplaceCmd = program
  .command('marketplace')
  .description('üè™ Gerenciar marketplace de agentes da comunidade');

marketplaceCmd
  .command('search [query]')
  .description('Buscar agentes no marketplace')
  .option('-c, --category <category>', 'Filtrar por categoria')
  .option('-f, --framework <framework>', 'Filtrar por framework')
  .option('-v, --verified', 'Apenas agentes verificados')
  .action(async (query, options) => {
    try {
      const marketplace = new MarketplaceManager();
      await marketplace.initialize();
      const results = await marketplace.searchAgents(query, options);
      await marketplace.displaySearchResults(results, true);
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na busca:'), error.message);
      process.exit(1);
    }
  });

marketplaceCmd
  .command('install <agentId>')
  .description('Instalar um agente do marketplace')
  .action(async (agentId) => {
    try {
      const marketplace = new MarketplaceManager();
      await marketplace.initialize();
      await marketplace.installAgent(agentId);
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na instala√ß√£o:'), error.message);
      process.exit(1);
    }
  });

marketplaceCmd
  .command('uninstall <agentId>')
  .description('Desinstalar um agente')
  .action(async (agentId) => {
    try {
      const marketplace = new MarketplaceManager();
      await marketplace.initialize();
      await marketplace.uninstallAgent(agentId);
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na desinstala√ß√£o:'), error.message);
      process.exit(1);
    }
  });

marketplaceCmd
  .command('list')
  .description('Listar agentes instalados')
  .action(async () => {
    try {
      const marketplace = new MarketplaceManager();
      await marketplace.initialize();
      await marketplace.listInstalled();
    } catch (error) {
      console.error(chalk.red('‚ùå Erro ao listar:'), error.message);
      process.exit(1);
    }
  });

marketplaceCmd
  .command('stats')
  .description('Estat√≠sticas do marketplace')
  .action(async () => {
    try {
      const marketplace = new MarketplaceManager();
      await marketplace.initialize();
      await marketplace.showStats();
    } catch (error) {
      console.error(chalk.red('‚ùå Erro ao mostrar estat√≠sticas:'), error.message);
      process.exit(1);
    }
  });

// Command: detect-framework - Detect project framework
program
  .command('detect-framework')
  .description('üîç Detectar framework do projeto')
  .option('-d, --detailed', 'Mostrar informa√ß√µes detalhadas')
  .action(async (options) => {
    try {
      const detector = new FrameworkDetector();
      await detector.loadConfig();
      const result = await detector.detectFramework(process.cwd());
      await detector.displayDetectionResult(result);

      if (options.detailed) {
        const agents = detector.getRecommendedAgents(result.primary);
        console.log(chalk.cyan('\nü§ñ Agentes otimizados para seu projeto:'));
        agents.forEach(agent => {
          console.log(chalk.gray(`   ‚Ä¢ ${agent}`));
        });
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Erro na detec√ß√£o:'), error.message);
      process.exit(1);
    }
  });

// Command: health - System health monitoring
program
  .command('health')
  .description('üè• Verificar sa√∫de dos agentes')
  .option('-r, --report', 'Gerar relat√≥rio completo')
  .option('--recover <agentName>', 'Tentar recuperar agente espec√≠fico')
  .action(async (options) => {
    try {
      const monitor = new HealthMonitor();
      await monitor.initialize();

      if (options.recover) {
        await monitor.performRecovery(options.recover);
      } else if (options.report) {
        await monitor.generateHealthReport();
      } else {
        await monitor.performHealthCheck();
      }

      // Stop monitoring after single check to prevent infinite loop
      await monitor.stopMonitoring();
    } catch (error) {
      console.error(chalk.red('‚ùå Erro no monitoramento:'), error.message);
      process.exit(1);
    }
  });

// Command: dashboard - Open analytics dashboard
program
  .command('dashboard')
  .description('üìä Abrir dashboard de analytics')
  .option('-p, --port <port>', 'Porta do servidor', '8082')
  .action(async (options) => {
    try {
      const server = new AnalyticsServer({ port: options.port });
      await server.start();

      // Keep server running
      process.on('SIGINT', async () => {
        console.log(chalk.yellow('\n‚èπÔ∏è Parando servidor...'));
        await server.stop();
        process.exit(0);
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Erro ao iniciar dashboard:'), error.message);
      process.exit(1);
    }
  });

// Main command - Execute demand
program
  .argument('[demand]', 'Demanda em linguagem natural')
  .option('-v, --verbose', 'Modo verbose com logs detalhados')
  .option('--dry-run', 'Simular execu√ß√£o sem fazer altera√ß√µes')
  .option('--pipeline <type>', 'For√ßar tipo de pipeline espec√≠fico')
  .option('--non-interactive', 'For√ßar modo n√£o-interativo (sem prompts do usu√°rio)')
  .option('--no-github', 'Pular integra√ß√£o GitHub (sem issue/PR)')
  .option('--enhanced', 'For√ßar modo Enhanced v2.0')
  .option('--standard', 'For√ßar modo Standard')
  .option('--educational', 'Ativar modo educacional')
  .option('--educational-verbosity <level>', 'N√≠vel de verbosidade educacional (minimal|standard|detailed|expert)', 'standard')
  .option('--no-monitor', 'Desabilitar monitor em tempo real')
  .option('--collect-metrics', 'Coletar m√©tricas de execu√ß√£o')
  .option('--auto-approve', 'Aprovar automaticamente todas as a√ß√µes do Claude (CUIDADO!)')
  .option('--interactive', 'For√ßar modo interativo com Claude')
  .action(async (demand, options) => {
    if (!demand) {
      console.log(chalk.yellow('üí° Exemplo de uso:'));
      console.log(chalk.cyan('  frontend-flow "criar bot√£o de login responsivo"'));
      console.log(chalk.cyan('  frontend-flow "implementar dashboard com gr√°ficos"'));
      console.log(chalk.cyan('  frontend-flow "otimizar performance da listagem"'));
      return;
    }

    console.log(chalk.blue('üöÄ Frontend Flow - Orquestrador de Agentes'));
    console.log(chalk.cyan(`üìù Demanda: "${demand}"`));
    console.log('');

    try {
      // Verificar se projeto est√° inicializado
      const projectPath = process.cwd();
      const configPath = path.join(projectPath, '.frontend-flow');

      if (!await fs.pathExists(configPath)) {
        console.log(chalk.yellow('‚ö†Ô∏è  Projeto n√£o inicializado. Executando init automaticamente...'));
        await initProject(projectPath, {});
        console.log(chalk.green('‚úÖ Projeto inicializado!'));
        console.log('');
      }

      // Analisar projeto
      console.log(chalk.blue('üîç Analisando projeto...'));
      const projectInfo = await analyzeProject(projectPath);
      console.log(chalk.green(`‚úÖ Projeto ${projectInfo.type} detectado`));
      console.log('');

      // Executar pipeline
      console.log(chalk.blue('ü§ñ Iniciando pipeline aut√¥nomo...'));
      const result = await runPipeline(demand, projectPath, {
        ...options,
        projectInfo
      });

      console.log('');
      console.log(chalk.green('üéâ Pipeline conclu√≠do com sucesso!'));
      console.log(chalk.cyan('üìä Resultados:'));
      console.log(`   ‚Ä¢ Tempo: ${result.duration}`);
      console.log(`   ‚Ä¢ Agentes executados: ${result.agentsExecuted}`);
      console.log(`   ‚Ä¢ Arquivos modificados: ${result.filesModified}`);

      if (result.pullRequest) {
        console.log(chalk.magenta(`   ‚Ä¢ Pull Request: ${result.pullRequest}`));
      }

      // Exit cleanly after success
      process.exit(0);

    } catch (error) {
      console.error('');
      console.error(chalk.red('‚ùå Erro na execu√ß√£o:'), error.message);

      if (options.verbose) {
        console.error(chalk.gray(error.stack));
      }

      console.error('');
      console.error(chalk.yellow('üí° Dicas:'));
      console.error('   ‚Ä¢ Use --verbose para mais detalhes');
      console.error('   ‚Ä¢ Verifique o arquivo de estado: .frontend-flow/temp/current_pipeline_state.md');
      console.error('   ‚Ä¢ Use frontend-flow status para ver o status atual');

      process.exit(1);
    }
  });

// Parse arguments
program.parse();

// Show help if no arguments provided
if (!process.argv.slice(2).length) {
  console.log(chalk.blue('üöÄ Frontend Flow - Orquestrador de Agentes'));
  console.log('');
  console.log(chalk.cyan('üí° Exemplos de uso:'));
  console.log('  frontend-flow init                           # Inicializar projeto');
  console.log('  frontend-flow "criar bot√£o responsivo"       # Executar demanda');
  console.log('  frontend-flow "dashboard com analytics"      # Feature completa');
  console.log('  frontend-flow status                        # Ver status');
  console.log('  frontend-flow clean                         # Limpar temp');
  console.log('');
  console.log(chalk.gray('Use --help para ver todas as op√ß√µes'));
}